{
  "blogPosts": [
    {
      "id": "deep-devs-proxy",
      "metadata": {
        "permalink": "/blog/deep-devs-proxy",
        "editUrl": "https://github.com/serverless-cd/website/tree/main/blog/2022-12-02-deep-devs-proxy.md",
        "source": "@site/blog/2022-12-02-deep-devs-proxy.md",
        "title": "Serverless-Devs 技术解析：全局proxy代理",
        "description": "Serverless Devs是一款企业级的，帮助用户管理Serverless应用全生命周期的开发者工具。企业内部有着比较严格的网络管控，比如可以控制下载哪些应用，访问哪些网站，以及浏览记录审计等。这些一般是通过代理服务器来实现。image.pngServerless-Devs是一个组件（插件）化的工具。通过热加载的技术，所有的业务能力都是动态加载执行的。意味着所有的组件开发者可以自由的使用自己的喜欢的库和网络进行交互。如果需要实现上述的代理的能力，不太可能case by case 的去做处理，就需要全局的代理的能力。",
        "date": "2022-12-02T00:00:00.000Z",
        "formattedDate": "2022年12月2日",
        "tags": [
          {
            "label": "CI/CD",
            "permalink": "/blog/tags/ci-cd"
          },
          {
            "label": "Serverless-Devs",
            "permalink": "/blog/tags/serverless-devs"
          }
        ],
        "readingTime": 5.1,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "丹坤",
            "title": "Founder of serverless-cd",
            "url": "https://github.com/heimanba",
            "imageURL": "https://avatars.githubusercontent.com/u/5129967?s=400&u=170b840efc18ce9d054062c85baec21ad29cc39c&v=4",
            "key": "mamba"
          },
          {
            "name": "首帅",
            "title": "Maintainer of serverless-cd",
            "url": "https://github.com/wss-git",
            "imageURL": "https://avatars.githubusercontent.com/u/56686088?v=4",
            "key": "wss"
          }
        ],
        "frontMatter": {
          "slug": "deep-devs-proxy",
          "title": "Serverless-Devs 技术解析：全局proxy代理",
          "authors": [
            "mamba",
            "wss"
          ],
          "tags": [
            "CI/CD",
            "Serverless-Devs"
          ]
        },
        "nextItem": {
          "title": "前端遇见Serverless：Nodejs 框架选型",
          "permalink": "/blog/fe2serverless-nodejs-framework"
        }
      },
      "content": "[Serverless Devs](https://github.com/Serverless-Devs/Serverless-Devs)是一款**企业级**的，帮助用户管理Serverless**应用全生命周期**的开发者工具。企业内部有着比较严格的网络管控，比如可以控制下载哪些应用，访问哪些网站，以及浏览记录审计等。这些一般是通过代理服务器来实现。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/22111491/1666267127530-205ad311-1f04-4402-ac94-d5ee93384553.png#clientId=u59a6cfdc-6adb-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=343&id=uf9aa8de8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=686&originWidth=1386&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144926&status=error&style=none&taskId=u92f34c0e-9a6e-4ed9-b29f-542425072b0&title=&width=693)<br />Serverless-Devs是一个组件（插件）化的工具。通过热加载的技术，所有的业务能力都是动态加载执行的。意味着所有的组件开发者可以自由的使用自己的喜欢的库和网络进行交互。如果需要实现上述的代理的能力，不太可能case by case 的去做处理，就需要全局的代理的能力。\n\n\n# HTTP 代理服务器搭建\nSquid 是一款广泛用于Linux和Unix平台的代理软件，对于我们实验有几个好处\n\n- 搭建简单\n- 可以方便查看访问日志，易于观察和验证\n\n## 在CentOS7安装Squid\n```\nsudo yum install squid\n```\n安装完成后，启动并启用Squid服务\n```\nsystemctl start squid\nsystemctl enable squid\n```\n验证是否成功，通过status命令查看\n```\nsystemctl status squid\n```\n\n## 修改默认配置\n打开squid.conf文件\n```\n/etc/squid/squid.conf\n```\n\n### 允许所有的IP进行代理访问\n```\nhttp_access allow all\n```\n\n### 允许代理HTTPS请求\n\n#### 创建一个自签名的SSL证书\n\n1. 转至 Squid 服务文件夹车，并创建SSL证书\n```\n$ cd /etc/squid\n$ openssl req -new -newkey rsa:2048 -nodes -x509 -keyout bump.key -out bump.crt\n```\n\n2. 将证书文件转换为 DER 格式的受信任证书以便它可以被导入浏览器中\n```\nopenssl x509 -in bump.crt -outform DER -out bump.der\n```\n\n#### 配置ssl_bump (适用于3.5.x版本)\n```\nhttp_port 3128 tcpkeepalive=60,30,3 ssl-bump generate-host-certificates=on dynamic_cert_mem_cache_size=20MB cert=/etc/squid/bump.crt key=/etc/squid/bump.key cipher=HIGH:MEDIUM:!LOW:!RC4:!SEED:!IDEA:!3DES:!MD5:!EXP:!PSK:!DSS options=NO_TLSv1,NO_SSLv3,NO_SSLv2,SINGLE_DH_USE,SINGLE_ECDH_USE tls-dh=prime256v1:/etc/squid/bump_dhparam.pem\n\nsslcrtd_program /usr/lib64/squid/ssl_crtd -s /var/lib/squid/ssl_db -M 20MB\n\nsslproxy_cert_error allow all\n\nssl_bump stare all\n```\n\n# 全局HTTP代理方案调研\n\n## http_proxy环境变量\n很多软件都识别http_proxy, https_proxy两个环境变量，比如curl ,wget\n\n- Linux/Unix和macOS配置\n```\nexport http_proxy=http://192.168.1.2:3128\nexport https_proxy=http://192.168.1.2:3128\n```\n通过终端输入 `env` 指令验证是否生效<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/22111491/1666269333135-c1bc6a5b-6f20-49ad-8422-ec09634e00df.png#clientId=u59a6cfdc-6adb-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=110&id=u2e3f3ab4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47141&status=error&style=none&taskId=u6ffe1853-573a-4d16-93b7-ab24bb602a5&title=&width=571)\n\n- Windows\n```\nset http_proxy=http://192.168.1.2:3128\nset https_proxy=http://192.168.1.2:3128\n```\n\n#### 通过access.log 验证 是否生效\n\n# ![squid.gif](https://cdn.nlark.com/yuque/0/2022/gif/22111491/1666281165969-794d9967-7376-490f-862d-96f0d8e455ac.gif#clientId=u5032cb36-1756-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=drop&id=u9e58ef55&margin=%5Bobject%20Object%5D&name=squid.gif&originHeight=500&originWidth=1192&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1373707&status=error&style=none&taskId=uaf24aec1-eade-4680-ac1f-51b817bcbb6&title=)\n我们可以看到配置了http_proxy  环境变量，在本地执行 `curl -i [http://www.aliyun.com/serverless](http://www.aliyun.com/serverless)` 能够自动代理到代理服务器中。<br />不过可惜的是Nodejs并不能自动识别这个环境变量\n\n\n## http.Agent\nhttp.Agent 主要是为 http.request, http.get 提供代理服务的，用于管理 http 连接的创建，销毁及复用工作。http.Agent默认使用 http.globalAgent 作为代理，每次请求都是“建立连接-数据传输-销毁连接”的过程，如果我们想让多个请求复用同一个 connection，则需要重新定义 agent 去覆盖默认的 http.globalAgent。基本所有Nodejs 生态的网络请求的库，都支持Agent模式\n\n### got\n[https://github.com/sindresorhus/got/blob/main/documentation/tips.md#proxying](https://github.com/sindresorhus/got/blob/main/documentation/tips.md#proxying)\n```\nimport got from 'got';\nimport {HttpsProxyAgent} from 'hpagent';\n\nawait got('https://sindresorhus.com', {\n\tagent: {\n\t\thttps: new HttpsProxyAgent({\n\t\t\tkeepAlive: true,\n\t\t\tkeepAliveMsecs: 1000,\n\t\t\tmaxSockets: 256,\n\t\t\tmaxFreeSockets: 256,\n\t\t\tscheduling: 'lifo',\n\t\t\tproxy: 'https://localhost:8080'\n\t\t})\n\t}\n});\n```\n\n### httpx\n[https://github.com/JacksonTian/httpx](https://github.com/JacksonTian/httpx)\n```\nconst proxy = require('proxy-agent');\nconst httpx = require('httpx');\n\nhttpx.request('http://www.baidu.com/', {\n  // pass a http proxy agent\n  agent: new ProxyAgent(\"https://yourproxy:123\")\n});\n```\n\n### axios\n[https://github.com/axios/axios](https://github.com/axios/axios)\n```\nproxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    // hostname: '127.0.0.1' // Takes precedence over 'host' if both are defined\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  }\n```\n\n但是很遗憾，在Serverless Devs生态中用到了基本上述的所有的库。不太可能逐一进行修改。\n\n## 全局代理\n本质上所有的请求都是使用下面几个原始的API\n```json\nconst httpGet = http.get;\nconst httpRequest = http.request;\nconst httpsGet = https.get;\nconst httpsRequest = https.request;\n```\n所以只需要在程序初始化之前，将`http.get` 替换为 `http.get({agent: proxyAgent})`，而这个这个其实就是 我们自己实现统一代理的Agent。[global-agent](https://www.npmjs.com/package/global-agent) 这个库已经帮我们做了相应的封装<br />下面是一个简单的Demo示例\n```\nconst httpx = require('httpx');\nconst globalAgent = require('global-agent');\n\nglobalAgent.bootstrap();\nglobal.GLOBAL_AGENT.HTTP_PROXY = \"http://192.168.1.2:3128\";\nglobal.GLOBAL_AGENT.HTTPS_PROXY = \"http://192.168.1.2:3128\";\n\nprocess.env[\"NODE_TLS_REJECT_UNAUTHORIZED\"] = 0;\n\n\nhttpx.request('http://www.aliyun.com/activity').then((response) => {\n  response.pipe(process.stdout);\n  response.on('end', () => {\n    process.stdout.write('end');\n  });\n}, (err) => {\n  console.log(err)\n  // on error\n});\n```\n通过观察Squid代理的 access.log，验证结果代理是生效的\n\n# 参考资料\n\n1. ssl bump 配置\n\n[https://support.kaspersky.com/KWTS/6.1/zh-Hans/166244.htm](https://support.kaspersky.com/KWTS/6.1/zh-Hans/166244.htm)<br />[https://foamzou.com/2017/09/23/squid-proxy-with-ssl-bump/](https://foamzou.com/2017/09/23/squid-proxy-with-ssl-bump/)\n\n2. nodejs全局代理\n\n[https://www.npmjs.com/package/global-agent](https://www.npmjs.com/package/global-agent)"
    },
    {
      "id": "fe2serverless-nodejs-framework",
      "metadata": {
        "permalink": "/blog/fe2serverless-nodejs-framework",
        "editUrl": "https://github.com/serverless-cd/website/tree/main/blog/2022-12-01-fe2serverless-nodejs-framework.md",
        "source": "@site/blog/2022-12-01-fe2serverless-nodejs-framework.md",
        "title": "前端遇见Serverless：Nodejs 框架选型",
        "description": "在FaaS 的世界中，Nodejs和Python是绝对的王者。Python在运维，AI以及数据处理方面有着非常广泛应用场景。而Nodejs备受前端开发者的青睐。前端的天职是专注于提供更好的用户体验，对服务器运维，高并发，弹性扩展等领域接触不多。有了FaaS后，前端同学只需要专注应用的开发。由于Nodejs应用一般应用在Api Server的web场景。根据网页打开3s打开原则，接口一般要求在1s之内返回，否则整体用户体验会比较糟糕。所以优化启动速度就成了重中之重。",
        "date": "2022-12-01T00:00:00.000Z",
        "formattedDate": "2022年12月1日",
        "tags": [
          {
            "label": "CI/CD",
            "permalink": "/blog/tags/ci-cd"
          },
          {
            "label": "Serverless-Devs",
            "permalink": "/blog/tags/serverless-devs"
          }
        ],
        "readingTime": 3.17,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "丹坤",
            "title": "Founder of serverless-cd",
            "url": "https://github.com/heimanba",
            "imageURL": "https://avatars.githubusercontent.com/u/5129967?s=400&u=170b840efc18ce9d054062c85baec21ad29cc39c&v=4",
            "key": "mamba"
          },
          {
            "name": "首帅",
            "title": "Maintainer of serverless-cd",
            "url": "https://github.com/wss-git",
            "imageURL": "https://avatars.githubusercontent.com/u/56686088?v=4",
            "key": "wss"
          }
        ],
        "frontMatter": {
          "slug": "fe2serverless-nodejs-framework",
          "title": "前端遇见Serverless：Nodejs 框架选型",
          "authors": [
            "mamba",
            "wss"
          ],
          "tags": [
            "CI/CD",
            "Serverless-Devs"
          ]
        },
        "prevItem": {
          "title": "Serverless-Devs 技术解析：全局proxy代理",
          "permalink": "/blog/deep-devs-proxy"
        }
      },
      "content": "在FaaS 的世界中，Nodejs和Python是绝对的王者。Python在运维，AI以及数据处理方面有着非常广泛应用场景。而Nodejs备受前端开发者的青睐。前端的天职是专注于提供更好的用户体验，对服务器运维，高并发，弹性扩展等领域接触不多。有了FaaS后，前端同学只需要专注应用的开发。由于Nodejs应用一般应用在Api Server的web场景。根据网页打开3s打开原则，接口一般要求在1s之内返回，否则整体用户体验会比较糟糕。所以优化启动速度就成了重中之重。\n\n# 什么是冷启动\n谈到FaaS,永远绕不开一个关键词 **冷启动**，冷启动犹如过街老鼠，各个Serverless的文章都在谈到如何优化冷启动。但是正是由于有了冷启动，我们才能享受FaaS的各种红利。\n\n## 冷启动带来的好处\n拿Nodejs举例，我们知道Nodejs是单线程的模型，这样的架构非常脆弱，一旦主线程有异常或者耗时操作，整个应用就崩溃了，同时也无法很好的利用操作系统的多核能力，提供更好的性能。Nodejs社区提供了[cluster](https://nodejs.org/api/cluster.html) 方案，实现了经典的master-worker的架构一方面更好的利用CPU多核能力，另一方面如果某个worker进程崩溃了，Master进程立即重新fork出新的Worker进程，保证服务的稳定性。很多Nodejs应用都会安装 [pm2](https://pm2.keymetrics.io/) 这样的进程管理工具，例如[egg.js](https://www.eggjs.org/) 框架通过`egg-cluster`提供了进程管理的能力\n```\n+---------+                 +---------+\n   |  Worker |                 |  Master |\n   +---------+                 +----+----+\n        | uncaughtException         |\n        +------------+              |\n        |            |              |                   +---------+\n        | <----------+              |                   |  Worker |\n        |                           |                   +----+----+\n        |        disconnect         |   fork a new worker    |\n        +-------------------------> + ---------------------> |\n        |         wait...           |                        |\n        |          exit             |                        |\n        +-------------------------> |                        |\n        |                           |                        |\n       die                          |                        |\n                                    |                        |\n                                    |                        |\n```\n\n有了FaaS后，就不需要使用上面的**cluster**模型了。<br />我们可以看到，每个request请求，FaaS平台都会新建一个单独的**新的实例**(instance)进行处理<br />所以多个请求之间并不会发生任何共享和抢占的行为，当然不会因为上一个用户请求异常造成下个用户不可用的情况，也保证了服务的高可用。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/22111491/1667390442726-8211f1de-c81a-488d-9e06-4bcb1bf2e273.png#clientId=u98dcae74-a366-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=454&id=u63a2ede7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&size=280671&status=done&style=none&taskId=u155aff6d-934e-4d10-a0b3-2740424ba79&title=&width=522)\n\n\n## 冷启动带来的问题\n我们在来详细看下在FaaS平台，Nodejs应用是如何启动的"
    }
  ]
}